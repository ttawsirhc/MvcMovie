/*
PART 4, ADD A MODEL TO AN ASP.NET CORE MVC APP
THEORY:
In this article: Add a data model class; Add NuGet packages; Scaffold movie pages; Initial migration
In this tutorial, classes are added for managing movies in a database.
These classes are the "Model" part of the MVC app.
These model classes are used with Entity Framework Core (EF Core) to work with a database.
EF Core is an object-relational mapping (ORM) framework that simplifies the data access code that you have to write.
The model classes created are known as POCO classes, from Plain Old CLR Objects.
POCO classes don't have any dependency on EF Core.
They only define the properties of the data to be stored in the database.
In this tutorial, model classes are created first, and EF Core creates the database.

PRACTICE:
ADD A DATA MODEL CLASS (Visual Studio Code)
1. Add a file named Movie.cs to the Models folder.
2. Update the Models/Movie.cs file with the following code: (SEE COPIED CODE AND COMMENTS)
A. The Movie class contains an Id field, which is required by the database for the primary key.
B. The DataType attribute on ReleaseDate specifies the type of the data (Date). With this attribute:
I. The user isn't required to enter time information in the date field.
II. Only the date is displayed, not time information.
III. DataAnnotations are covered in a later tutorial.
IV. The question mark after string indicates that the property is nullable.
V. For more information, see Nullable reference types.
3. Add NuGet packages (Visual Studio Code)
A. Run the following .NET CLI commands: (.NET CLI)
dotnet tool uninstall --global dotnet-aspnet-codegenerator
dotnet tool install --global dotnet-aspnet-codegenerator
dotnet tool uninstall --global dotnet-ef
dotnet tool install --global dotnet-ef
dotnet add package Microsoft.EntityFrameworkCore.Design
dotnet add package Microsoft.EntityFrameworkCore.SQLite
dotnet add package Microsoft.VisualStudio.Web.CodeGeneration.Design
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
B. The preceding commands add:
I. The command-line interface (CLI) tools for EF Core
II. The aspnet-codegenerator scaffolding tool.
III. Design time tools for EF Core
IV. The EF Core SQLite provider, which installs the EF Core package as a dependency.
V. Packages needed for scaffolding: Microsoft.VisualStudio.Web.CodeGeneration.Design and Microsoft.EntityFrameworkCore.SqlServer.
VI. For guidance on multiple environment configuration that permits an app to configure its database contexts by environment, see Use multiple environments in ASP.NET Core.
C. NOTE: By default the architecture of the .NET binaries to install represents the currently running OS architecture.
A. To specify a different OS architecture, see dotnet tool install, --arch option.
B. For more information, see GitHub issue dotnet/AspNetCore.Docs #29262.
4. In Visual Studio Code, press Ctrl+F5 (Windows) or âŒ˜+F5 (macOS) to run the app without debugging.
A. In the Panel below the editor region, select the PROBLEMS tab, or from the View menu, select Problems if it is not currently in view.
B. Verify there are no compilation errors.
SCAFFOLD MOVIE PAGES
5. Use the scaffolding tool to produce Create, Read, Update, and Delete (CRUD) pages for the movie model. (Visual Studio Code)
6. Open a command window in the project directory.
A. The project directory is the directory that contains the Program.cs and .csproj files.
7. ON MACOS AND LINUX, EXPORT THE SCAFFOLD TOOL PATH: (Console): export PATH=$HOME/.dotnet/tools:$PATH
8. Run the following command (.NET CLI):
A. dotnet aspnet-codegenerator controller -name MoviesController -m Movie -dc MvcMovie.Data.MvcMovieContext --relativeFolderPath Controllers --useDefaultLayout --referenceScriptLibraries --databaseProvider sqlite
B. The following table details the ASP.NET Core code generator parameters ^^:
Parameter 	                    Description
-m 	                            The name of the model.
-dc 	                        The data context.
--relativeFolderPath 	        The relative output folder path to create the files.
--useDefaultLayout|-udl 	    The default layout should be used for the views.
--referenceScriptLibraries 	    Adds _ValidationScriptsPartial to Edit and Create pages.
--databaseProvider sqlite 	    Specify DbContext should use SQLite instead of SQL Server.
9. Use the h switch to get help on the aspnet-codegenerator controller command (.NET CLI):
A. dotnet aspnet-codegenerator controller -h
B. For more information, see dotnet aspnet-codegenerator
10. Scaffolding creates the following:
A. A movies controller: Controllers/MoviesController.cs
B. Razor view files for Create, Delete, Details, Edit, and Index pages: Views/Movies/*.cshtml
C. A database context class: Data/MvcMovieContext.cs
11. Scaffolding updates the following:
A. Registers the database context in the Program.cs file
B. Adds a database connection string to the appsettings.json file.
12. The automatic creation of these files and file updates is known as scaffolding.
13. The scaffolded pages can't be used yet because the database doesn't exist.
14. Running the app and selecting the Movie App link results in a Cannot open database or no such table: Movie error message.
15. Build the app to verify that there are no errors.
USE SQLITE FOR DEVELOPMENT, SQL SERVER FOR PRODUCTION
16. SEE UPDATES AND COMMENTS IN /Program.cs (C#)
INITIAL MIGRATION
17. Use the EF Core Migrations feature to create the database.
A. Migrations is a set of tools that create and update a database to match the data model. (Visual Studio Code)
18. Run the following .NET CLI commands: dotnet ef migrations add InitialCreate ; dotnet ef database update
A. ef migrations add InitialCreate: Generates a Migrations/{timestamp}_InitialCreate.cs migration file.
B. The InitialCreate argument is the migration name.
C. Any name can be used, but by convention, a name is selected that describes the migration.
D. This is the first migration, so the generated class contains code to create the database schema.
E. The database schema is based on the model specified in the MvcMovieContext class, in the Data/MvcMovieContext.cs file.
F. ef database update: Updates the database to the latest migration, which the previous command created.
G. This command runs the Up method in the Migrations/{time-stamp}_InitialCreate.cs file, which creates the database.
H. For more information on maintaining multiple providers such as Microsoft SQL Server and SQLite, see Migrations with Multiple Providers.
TEST THE APP (Visual Studio Code)
1. Run the app and select the Movie App link.
A. If you get an exception similar to the following, you may have missed the dotnet ef database update command in the migrations step:
I. SqliteException: SQLite Error 1: 'no such table: Movie'.
B. NOTE: You may not be able to enter decimal commas in the Price field.
I. To support jQuery validation for non-English locales that use a comma (",")
II. for a decimal point and for non US-English date formats, the app must be globalized.
III. For globalization instructions, see this GitHub issue.

Examine the generated database context class and registration

With EF Core, data access is performed using a model. A model is made up of entity classes and a context object that represents a session with the database. The context object allows querying and saving data. The database context is derived from Microsoft.EntityFrameworkCore.DbContext and specifies the entities to include in the data model.

Scaffolding creates the Data/MvcMovieContext.cs database context class:
C#

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using MvcMovie.Models;

namespace MvcMovie.Data
{
    public class MvcMovieContext : DbContext
    {
        public MvcMovieContext (DbContextOptions<MvcMovieContext> options)
            : base(options)
        {
        }

        public DbSet<MvcMovie.Models.Movie> Movie { get; set; }
    }
}

The preceding code creates a DbSet<Movie> property that represents the movies in the database.
Dependency injection

ASP.NET Core is built with dependency injection (DI). Services, such as the database context, are registered with DI in Program.cs. These services are provided to components that require them via constructor parameters.

In the Controllers/MoviesController.cs file, the constructor uses Dependency Injection to inject the MvcMovieContext database context into the controller. The database context is used in each of the CRUD methods in the controller.

Scaffolding generated the following highlighted code in Program.cs:

    Visual Studio
    Visual Studio Code / Visual Studio for Mac

C#

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddDbContext<MvcMovieContext>(options =>
    options.UseSqlite(builder.Configuration.GetConnectionString("MvcMovieContext")));

The ASP.NET Core configuration system reads the "MvcMovieContext" database connection string.

Examine the generated database connection string

Scaffolding added a connection string to the appsettings.json file:

    Visual Studio
    Visual Studio Code / Visual Studio for Mac

JSON

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "MvcMovieContext": "Data Source=MvcMovie.db"
  }
}

For local development, the ASP.NET Core configuration system reads the ConnectionString key from the appsettings.json file.
The InitialCreate class

Examine the Migrations/{timestamp}_InitialCreate.cs migration file:
C#

using System;
using Microsoft.EntityFrameworkCore.Migrations;

#nullable disable

namespace MvcMovie.Migrations
{
    public partial class InitialCreate : Migration
    {
        protected override void Up(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.CreateTable(
                name: "Movie",
                columns: table => new
                {
                    Id = table.Column<int>(type: "int", nullable: false)
                        .Annotation("SqlServer:Identity", "1, 1"),
                    Title = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    ReleaseDate = table.Column<DateTime>(type: "datetime2", nullable: false),
                    Genre = table.Column<string>(type: "nvarchar(max)", nullable: true),
                    Price = table.Column<decimal>(type: "decimal(18,2)", nullable: false)
                },
                constraints: table =>
                {
                    table.PrimaryKey("PK_Movie", x => x.Id);
                });
        }

        protected override void Down(MigrationBuilder migrationBuilder)
        {
            migrationBuilder.DropTable(
                name: "Movie");
        }
    }
}

In the preceding code:

    InitialCreate.Up creates the Movie table and configures Id as the primary key.
    InitialCreate.Down reverts the schema changes made by the Up migration.

Dependency injection in the controller

Open the Controllers/MoviesController.cs file and examine the constructor:
C#

public class MoviesController : Controller
{
    private readonly MvcMovieContext _context;

    public MoviesController(MvcMovieContext context)
    {
        _context = context;
    }

The constructor uses Dependency Injection to inject the database context (MvcMovieContext) into the controller. The database context is used in each of the CRUD methods in the controller.

Test the Create page. Enter and submit data.

Test the Edit, Details, and Delete pages.

Strongly typed models and the @model directive

Earlier in this tutorial, you saw how a controller can pass data or objects to a view using the ViewData dictionary. The ViewData dictionary is a dynamic object that provides a convenient late-bound way to pass information to a view.

MVC provides the ability to pass strongly typed model objects to a view. This strongly typed approach enables compile time code checking. The scaffolding mechanism passed a strongly typed model in the MoviesController class and views.

Examine the generated Details method in the Controllers/MoviesController.cs file:
C#

// GET: Movies/Details/5
public async Task<IActionResult> Details(int? id)
{
    if (id == null)
    {
        return NotFound();
    }

    var movie = await _context.Movie
        .FirstOrDefaultAsync(m => m.Id == id);
    if (movie == null)
    {
        return NotFound();
    }

    return View(movie);
}

The id parameter is generally passed as route data. For example, https://localhost:5001/movies/details/1 sets:

    The controller to the movies controller, the first URL segment.
    The action to details, the second URL segment.
    The id to 1, the last URL segment.

The id can be passed in with a query string, as in the following example:

https://localhost:5001/movies/details?id=1

The id parameter is defined as a nullable type (int?) in cases when the id value isn't provided.

A lambda expression is passed in to the FirstOrDefaultAsync method to select movie entities that match the route data or query string value.
C#

var movie = await _context.Movie
    .FirstOrDefaultAsync(m => m.Id == id);

If a movie is found, an instance of the Movie model is passed to the Details view:
C#

return View(movie);

Examine the contents of the Views/Movies/Details.cshtml file:
CSHTML

@model MvcMovie.Models.Movie

@{
    ViewData["Title"] = "Details";
}

<h1>Details</h1>

<div>
    <h4>Movie</h4>
    <hr />
    <dl class="row">
        <dt class = "col-sm-2">
            @Html.DisplayNameFor(model => model.Title)
        </dt>
        <dd class = "col-sm-10">
            @Html.DisplayFor(model => model.Title)
        </dd>
        <dt class = "col-sm-2">
            @Html.DisplayNameFor(model => model.ReleaseDate)
        </dt>
        <dd class = "col-sm-10">
            @Html.DisplayFor(model => model.ReleaseDate)
        </dd>
        <dt class = "col-sm-2">
            @Html.DisplayNameFor(model => model.Genre)
        </dt>
        <dd class = "col-sm-10">
            @Html.DisplayFor(model => model.Genre)
        </dd>
        <dt class = "col-sm-2">
            @Html.DisplayNameFor(model => model.Price)
        </dt>
        <dd class = "col-sm-10">
            @Html.DisplayFor(model => model.Price)
        </dd>
    </dl>
</div>
<div>
    <a asp-action="Edit" asp-route-id="@Model.Id">Edit</a> |
    <a asp-action="Index">Back to List</a>
</div>

The @model statement at the top of the view file specifies the type of object that the view expects. When the movie controller was created, the following @model statement was included:
CSHTML

@model MvcMovie.Models.Movie

This @model directive allows access to the movie that the controller passed to the view. The Model object is strongly typed. For example, in the Details.cshtml view, the code passes each movie field to the DisplayNameFor and DisplayFor HTML Helpers with the strongly typed Model object. The Create and Edit methods and views also pass a Movie model object.

Examine the Index.cshtml view and the Index method in the Movies controller. Notice how the code creates a List object when it calls the View method. The code passes this Movies list from the Index action method to the view:
C#

// GET: Movies
public async Task<IActionResult> Index()
{
    return View(await _context.Movie.ToListAsync());
}

The code returns problem details if the Movie property of the data context is null.

When the movies controller was created, scaffolding included the following @model statement at the top of the Index.cshtml file:
CSHTML

@model IEnumerable<MvcMovie.Models.Movie>

The @model directive allows access to the list of movies that the controller passed to the view by using a Model object that's strongly typed. For example, in the Index.cshtml view, the code loops through the movies with a foreach statement over the strongly typed Model object:
CSHTML

@model IEnumerable<MvcMovie.Models.Movie>

@{
    ViewData["Title"] = "Index";
}

<h1>Index</h1>

<p>
    <a asp-action="Create">Create New</a>
</p>
<table class="table">
    <thead>
        <tr>
            <th>
                @Html.DisplayNameFor(model => model.Title)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.ReleaseDate)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.Genre)
            </th>
            <th>
                @Html.DisplayNameFor(model => model.Price)
            </th>
            <th></th>
        </tr>
    </thead>
    <tbody>
@foreach (var item in Model) {
        <tr>
            <td>
                @Html.DisplayFor(modelItem => item.Title)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.ReleaseDate)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Genre)
            </td>
            <td>
                @Html.DisplayFor(modelItem => item.Price)
            </td>
            <td>
                <a asp-action="Edit" asp-route-id="@item.Id">Edit</a> |
                <a asp-action="Details" asp-route-id="@item.Id">Details</a> |
                <a asp-action="Delete" asp-route-id="@item.Id">Delete</a>
            </td>
        </tr>
}
    </tbody>
</table>

Because the Model object is strongly typed as an IEnumerable<Movie> object, each item in the loop is typed as Movie. Among other benefits, the compiler validates the types used in the code.
Additional resources

    Entity Framework Core for Beginners
    Tag Helpers
    Globalization and localization
*/
